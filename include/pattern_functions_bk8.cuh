#pragma once

/* Auto-generated pattern-specialized compute functions for BK=8 */
/* Generated by generate_pattern_functions.py */

#include <cuda_runtime.h>

// Each pattern function handles one specific 8-bit sparsity pattern
// with completely unrolled computation and zero branches.

// ============================================================================
// PATTERN-SPECIALIZED COMPUTE FUNCTIONS (6 total)
// ============================================================================

// Pattern 0x0f (0b00001111) - 4 active columns
__device__ inline void compute_pattern_15(
    const float* __restrict__ As,
    const float* __restrict__ Bs,
    float* __restrict__ threadResults,
    const uint warpRow, const uint warpCol,
    const uint threadRowInWarp, const uint threadColInWarp,
    const uint WM, const uint WN, const uint TM, const uint TN,
    const uint BM, const uint BN, const uint WMITER, const uint WNITER,
    const uint WSUBM, const uint WSUBN
) {
    // Temporary register storage (reused for each column)
    float regM[8];  // Support up to WMITER=8, TM=1
    float regN[32];  // Support up to WNITER=4, TN=8

    // Column 0
    {
        for (uint wSubRowIdx = 0; wSubRowIdx < WMITER; ++wSubRowIdx) {
            regM[wSubRowIdx] = As[(0 * BM) + warpRow * WM + 
                wSubRowIdx * WSUBM + threadRowInWarp * TM];
        }

        for (uint wSubColIdx = 0; wSubColIdx < WNITER; ++wSubColIdx) {
            #pragma unroll
            for (uint tn = 0; tn < TN; ++tn) {
                regN[wSubColIdx * TN + tn] = Bs[(0 * BN) + warpCol * WN + 
                    wSubColIdx * WSUBN + threadColInWarp * TN + tn];
            }
        }

        for (uint wSubRowIdx = 0; wSubRowIdx < WMITER; ++wSubRowIdx) {
            for (uint wSubColIdx = 0; wSubColIdx < WNITER; ++wSubColIdx) {
                #pragma unroll
                for (uint tn = 0; tn < TN; ++tn) {
                    const uint idx = (wSubRowIdx * TM) * (WNITER * TN) + 
                        wSubColIdx * TN + tn;
                    threadResults[idx] += regM[wSubRowIdx] * regN[wSubColIdx * TN + tn];
                }
            }
        }
    }

    // Column 1
    {
        for (uint wSubRowIdx = 0; wSubRowIdx < WMITER; ++wSubRowIdx) {
            regM[wSubRowIdx] = As[(1 * BM) + warpRow * WM + 
                wSubRowIdx * WSUBM + threadRowInWarp * TM];
        }

        for (uint wSubColIdx = 0; wSubColIdx < WNITER; ++wSubColIdx) {
            #pragma unroll
            for (uint tn = 0; tn < TN; ++tn) {
                regN[wSubColIdx * TN + tn] = Bs[(1 * BN) + warpCol * WN + 
                    wSubColIdx * WSUBN + threadColInWarp * TN + tn];
            }
        }

        for (uint wSubRowIdx = 0; wSubRowIdx < WMITER; ++wSubRowIdx) {
            for (uint wSubColIdx = 0; wSubColIdx < WNITER; ++wSubColIdx) {
                #pragma unroll
                for (uint tn = 0; tn < TN; ++tn) {
                    const uint idx = (wSubRowIdx * TM) * (WNITER * TN) + 
                        wSubColIdx * TN + tn;
                    threadResults[idx] += regM[wSubRowIdx] * regN[wSubColIdx * TN + tn];
                }
            }
        }
    }

    // Column 2
    {
        for (uint wSubRowIdx = 0; wSubRowIdx < WMITER; ++wSubRowIdx) {
            regM[wSubRowIdx] = As[(2 * BM) + warpRow * WM + 
                wSubRowIdx * WSUBM + threadRowInWarp * TM];
        }

        for (uint wSubColIdx = 0; wSubColIdx < WNITER; ++wSubColIdx) {
            #pragma unroll
            for (uint tn = 0; tn < TN; ++tn) {
                regN[wSubColIdx * TN + tn] = Bs[(2 * BN) + warpCol * WN + 
                    wSubColIdx * WSUBN + threadColInWarp * TN + tn];
            }
        }

        for (uint wSubRowIdx = 0; wSubRowIdx < WMITER; ++wSubRowIdx) {
            for (uint wSubColIdx = 0; wSubColIdx < WNITER; ++wSubColIdx) {
                #pragma unroll
                for (uint tn = 0; tn < TN; ++tn) {
                    const uint idx = (wSubRowIdx * TM) * (WNITER * TN) + 
                        wSubColIdx * TN + tn;
                    threadResults[idx] += regM[wSubRowIdx] * regN[wSubColIdx * TN + tn];
                }
            }
        }
    }

    // Column 3
    {
        for (uint wSubRowIdx = 0; wSubRowIdx < WMITER; ++wSubRowIdx) {
            regM[wSubRowIdx] = As[(3 * BM) + warpRow * WM + 
                wSubRowIdx * WSUBM + threadRowInWarp * TM];
        }

        for (uint wSubColIdx = 0; wSubColIdx < WNITER; ++wSubColIdx) {
            #pragma unroll
            for (uint tn = 0; tn < TN; ++tn) {
                regN[wSubColIdx * TN + tn] = Bs[(3 * BN) + warpCol * WN + 
                    wSubColIdx * WSUBN + threadColInWarp * TN + tn];
            }
        }

        for (uint wSubRowIdx = 0; wSubRowIdx < WMITER; ++wSubRowIdx) {
            for (uint wSubColIdx = 0; wSubColIdx < WNITER; ++wSubColIdx) {
                #pragma unroll
                for (uint tn = 0; tn < TN; ++tn) {
                    const uint idx = (wSubRowIdx * TM) * (WNITER * TN) + 
                        wSubColIdx * TN + tn;
                    threadResults[idx] += regM[wSubRowIdx] * regN[wSubColIdx * TN + tn];
                }
            }
        }
    }

}

// Pattern 0x80 (0b10000000) - 1 active columns
__device__ inline void compute_pattern_128(
    const float* __restrict__ As,
    const float* __restrict__ Bs,
    float* __restrict__ threadResults,
    const uint warpRow, const uint warpCol,
    const uint threadRowInWarp, const uint threadColInWarp,
    const uint WM, const uint WN, const uint TM, const uint TN,
    const uint BM, const uint BN, const uint WMITER, const uint WNITER,
    const uint WSUBM, const uint WSUBN
) {
    // Temporary register storage (reused for each column)
    float regM[8];  // Support up to WMITER=8, TM=1
    float regN[32];  // Support up to WNITER=4, TN=8

    // Column 7
    {
        for (uint wSubRowIdx = 0; wSubRowIdx < WMITER; ++wSubRowIdx) {
            regM[wSubRowIdx] = As[(7 * BM) + warpRow * WM + 
                wSubRowIdx * WSUBM + threadRowInWarp * TM];
        }

        for (uint wSubColIdx = 0; wSubColIdx < WNITER; ++wSubColIdx) {
            #pragma unroll
            for (uint tn = 0; tn < TN; ++tn) {
                regN[wSubColIdx * TN + tn] = Bs[(7 * BN) + warpCol * WN + 
                    wSubColIdx * WSUBN + threadColInWarp * TN + tn];
            }
        }

        for (uint wSubRowIdx = 0; wSubRowIdx < WMITER; ++wSubRowIdx) {
            for (uint wSubColIdx = 0; wSubColIdx < WNITER; ++wSubColIdx) {
                #pragma unroll
                for (uint tn = 0; tn < TN; ++tn) {
                    const uint idx = (wSubRowIdx * TM) * (WNITER * TN) + 
                        wSubColIdx * TN + tn;
                    threadResults[idx] += regM[wSubRowIdx] * regN[wSubColIdx * TN + tn];
                }
            }
        }
    }

}

// Pattern 0xc0 (0b11000000) - 2 active columns
__device__ inline void compute_pattern_192(
    const float* __restrict__ As,
    const float* __restrict__ Bs,
    float* __restrict__ threadResults,
    const uint warpRow, const uint warpCol,
    const uint threadRowInWarp, const uint threadColInWarp,
    const uint WM, const uint WN, const uint TM, const uint TN,
    const uint BM, const uint BN, const uint WMITER, const uint WNITER,
    const uint WSUBM, const uint WSUBN
) {
    // Temporary register storage (reused for each column)
    float regM[8];  // Support up to WMITER=8, TM=1
    float regN[32];  // Support up to WNITER=4, TN=8

    // Column 6
    {
        for (uint wSubRowIdx = 0; wSubRowIdx < WMITER; ++wSubRowIdx) {
            regM[wSubRowIdx] = As[(6 * BM) + warpRow * WM + 
                wSubRowIdx * WSUBM + threadRowInWarp * TM];
        }

        for (uint wSubColIdx = 0; wSubColIdx < WNITER; ++wSubColIdx) {
            #pragma unroll
            for (uint tn = 0; tn < TN; ++tn) {
                regN[wSubColIdx * TN + tn] = Bs[(6 * BN) + warpCol * WN + 
                    wSubColIdx * WSUBN + threadColInWarp * TN + tn];
            }
        }

        for (uint wSubRowIdx = 0; wSubRowIdx < WMITER; ++wSubRowIdx) {
            for (uint wSubColIdx = 0; wSubColIdx < WNITER; ++wSubColIdx) {
                #pragma unroll
                for (uint tn = 0; tn < TN; ++tn) {
                    const uint idx = (wSubRowIdx * TM) * (WNITER * TN) + 
                        wSubColIdx * TN + tn;
                    threadResults[idx] += regM[wSubRowIdx] * regN[wSubColIdx * TN + tn];
                }
            }
        }
    }

    // Column 7
    {
        for (uint wSubRowIdx = 0; wSubRowIdx < WMITER; ++wSubRowIdx) {
            regM[wSubRowIdx] = As[(7 * BM) + warpRow * WM + 
                wSubRowIdx * WSUBM + threadRowInWarp * TM];
        }

        for (uint wSubColIdx = 0; wSubColIdx < WNITER; ++wSubColIdx) {
            #pragma unroll
            for (uint tn = 0; tn < TN; ++tn) {
                regN[wSubColIdx * TN + tn] = Bs[(7 * BN) + warpCol * WN + 
                    wSubColIdx * WSUBN + threadColInWarp * TN + tn];
            }
        }

        for (uint wSubRowIdx = 0; wSubRowIdx < WMITER; ++wSubRowIdx) {
            for (uint wSubColIdx = 0; wSubColIdx < WNITER; ++wSubColIdx) {
                #pragma unroll
                for (uint tn = 0; tn < TN; ++tn) {
                    const uint idx = (wSubRowIdx * TM) * (WNITER * TN) + 
                        wSubColIdx * TN + tn;
                    threadResults[idx] += regM[wSubRowIdx] * regN[wSubColIdx * TN + tn];
                }
            }
        }
    }

}

// Pattern 0xf0 (0b11110000) - 4 active columns
__device__ inline void compute_pattern_240(
    const float* __restrict__ As,
    const float* __restrict__ Bs,
    float* __restrict__ threadResults,
    const uint warpRow, const uint warpCol,
    const uint threadRowInWarp, const uint threadColInWarp,
    const uint WM, const uint WN, const uint TM, const uint TN,
    const uint BM, const uint BN, const uint WMITER, const uint WNITER,
    const uint WSUBM, const uint WSUBN
) {
    // Temporary register storage (reused for each column)
    float regM[8];  // Support up to WMITER=8, TM=1
    float regN[32];  // Support up to WNITER=4, TN=8

    // Column 4
    {
        for (uint wSubRowIdx = 0; wSubRowIdx < WMITER; ++wSubRowIdx) {
            regM[wSubRowIdx] = As[(4 * BM) + warpRow * WM + 
                wSubRowIdx * WSUBM + threadRowInWarp * TM];
        }

        for (uint wSubColIdx = 0; wSubColIdx < WNITER; ++wSubColIdx) {
            #pragma unroll
            for (uint tn = 0; tn < TN; ++tn) {
                regN[wSubColIdx * TN + tn] = Bs[(4 * BN) + warpCol * WN + 
                    wSubColIdx * WSUBN + threadColInWarp * TN + tn];
            }
        }

        for (uint wSubRowIdx = 0; wSubRowIdx < WMITER; ++wSubRowIdx) {
            for (uint wSubColIdx = 0; wSubColIdx < WNITER; ++wSubColIdx) {
                #pragma unroll
                for (uint tn = 0; tn < TN; ++tn) {
                    const uint idx = (wSubRowIdx * TM) * (WNITER * TN) + 
                        wSubColIdx * TN + tn;
                    threadResults[idx] += regM[wSubRowIdx] * regN[wSubColIdx * TN + tn];
                }
            }
        }
    }

    // Column 5
    {
        for (uint wSubRowIdx = 0; wSubRowIdx < WMITER; ++wSubRowIdx) {
            regM[wSubRowIdx] = As[(5 * BM) + warpRow * WM + 
                wSubRowIdx * WSUBM + threadRowInWarp * TM];
        }

        for (uint wSubColIdx = 0; wSubColIdx < WNITER; ++wSubColIdx) {
            #pragma unroll
            for (uint tn = 0; tn < TN; ++tn) {
                regN[wSubColIdx * TN + tn] = Bs[(5 * BN) + warpCol * WN + 
                    wSubColIdx * WSUBN + threadColInWarp * TN + tn];
            }
        }

        for (uint wSubRowIdx = 0; wSubRowIdx < WMITER; ++wSubRowIdx) {
            for (uint wSubColIdx = 0; wSubColIdx < WNITER; ++wSubColIdx) {
                #pragma unroll
                for (uint tn = 0; tn < TN; ++tn) {
                    const uint idx = (wSubRowIdx * TM) * (WNITER * TN) + 
                        wSubColIdx * TN + tn;
                    threadResults[idx] += regM[wSubRowIdx] * regN[wSubColIdx * TN + tn];
                }
            }
        }
    }

    // Column 6
    {
        for (uint wSubRowIdx = 0; wSubRowIdx < WMITER; ++wSubRowIdx) {
            regM[wSubRowIdx] = As[(6 * BM) + warpRow * WM + 
                wSubRowIdx * WSUBM + threadRowInWarp * TM];
        }

        for (uint wSubColIdx = 0; wSubColIdx < WNITER; ++wSubColIdx) {
            #pragma unroll
            for (uint tn = 0; tn < TN; ++tn) {
                regN[wSubColIdx * TN + tn] = Bs[(6 * BN) + warpCol * WN + 
                    wSubColIdx * WSUBN + threadColInWarp * TN + tn];
            }
        }

        for (uint wSubRowIdx = 0; wSubRowIdx < WMITER; ++wSubRowIdx) {
            for (uint wSubColIdx = 0; wSubColIdx < WNITER; ++wSubColIdx) {
                #pragma unroll
                for (uint tn = 0; tn < TN; ++tn) {
                    const uint idx = (wSubRowIdx * TM) * (WNITER * TN) + 
                        wSubColIdx * TN + tn;
                    threadResults[idx] += regM[wSubRowIdx] * regN[wSubColIdx * TN + tn];
                }
            }
        }
    }

    // Column 7
    {
        for (uint wSubRowIdx = 0; wSubRowIdx < WMITER; ++wSubRowIdx) {
            regM[wSubRowIdx] = As[(7 * BM) + warpRow * WM + 
                wSubRowIdx * WSUBM + threadRowInWarp * TM];
        }

        for (uint wSubColIdx = 0; wSubColIdx < WNITER; ++wSubColIdx) {
            #pragma unroll
            for (uint tn = 0; tn < TN; ++tn) {
                regN[wSubColIdx * TN + tn] = Bs[(7 * BN) + warpCol * WN + 
                    wSubColIdx * WSUBN + threadColInWarp * TN + tn];
            }
        }

        for (uint wSubRowIdx = 0; wSubRowIdx < WMITER; ++wSubRowIdx) {
            for (uint wSubColIdx = 0; wSubColIdx < WNITER; ++wSubColIdx) {
                #pragma unroll
                for (uint tn = 0; tn < TN; ++tn) {
                    const uint idx = (wSubRowIdx * TM) * (WNITER * TN) + 
                        wSubColIdx * TN + tn;
                    threadResults[idx] += regM[wSubRowIdx] * regN[wSubColIdx * TN + tn];
                }
            }
        }
    }

}

// Pattern 0xfc (0b11111100) - 6 active columns
__device__ inline void compute_pattern_252(
    const float* __restrict__ As,
    const float* __restrict__ Bs,
    float* __restrict__ threadResults,
    const uint warpRow, const uint warpCol,
    const uint threadRowInWarp, const uint threadColInWarp,
    const uint WM, const uint WN, const uint TM, const uint TN,
    const uint BM, const uint BN, const uint WMITER, const uint WNITER,
    const uint WSUBM, const uint WSUBN
) {
    // Temporary register storage (reused for each column)
    float regM[8];  // Support up to WMITER=8, TM=1
    float regN[32];  // Support up to WNITER=4, TN=8

    // Column 2
    {
        for (uint wSubRowIdx = 0; wSubRowIdx < WMITER; ++wSubRowIdx) {
            regM[wSubRowIdx] = As[(2 * BM) + warpRow * WM + 
                wSubRowIdx * WSUBM + threadRowInWarp * TM];
        }

        for (uint wSubColIdx = 0; wSubColIdx < WNITER; ++wSubColIdx) {
            #pragma unroll
            for (uint tn = 0; tn < TN; ++tn) {
                regN[wSubColIdx * TN + tn] = Bs[(2 * BN) + warpCol * WN + 
                    wSubColIdx * WSUBN + threadColInWarp * TN + tn];
            }
        }

        for (uint wSubRowIdx = 0; wSubRowIdx < WMITER; ++wSubRowIdx) {
            for (uint wSubColIdx = 0; wSubColIdx < WNITER; ++wSubColIdx) {
                #pragma unroll
                for (uint tn = 0; tn < TN; ++tn) {
                    const uint idx = (wSubRowIdx * TM) * (WNITER * TN) + 
                        wSubColIdx * TN + tn;
                    threadResults[idx] += regM[wSubRowIdx] * regN[wSubColIdx * TN + tn];
                }
            }
        }
    }

    // Column 3
    {
        for (uint wSubRowIdx = 0; wSubRowIdx < WMITER; ++wSubRowIdx) {
            regM[wSubRowIdx] = As[(3 * BM) + warpRow * WM + 
                wSubRowIdx * WSUBM + threadRowInWarp * TM];
        }

        for (uint wSubColIdx = 0; wSubColIdx < WNITER; ++wSubColIdx) {
            #pragma unroll
            for (uint tn = 0; tn < TN; ++tn) {
                regN[wSubColIdx * TN + tn] = Bs[(3 * BN) + warpCol * WN + 
                    wSubColIdx * WSUBN + threadColInWarp * TN + tn];
            }
        }

        for (uint wSubRowIdx = 0; wSubRowIdx < WMITER; ++wSubRowIdx) {
            for (uint wSubColIdx = 0; wSubColIdx < WNITER; ++wSubColIdx) {
                #pragma unroll
                for (uint tn = 0; tn < TN; ++tn) {
                    const uint idx = (wSubRowIdx * TM) * (WNITER * TN) + 
                        wSubColIdx * TN + tn;
                    threadResults[idx] += regM[wSubRowIdx] * regN[wSubColIdx * TN + tn];
                }
            }
        }
    }

    // Column 4
    {
        for (uint wSubRowIdx = 0; wSubRowIdx < WMITER; ++wSubRowIdx) {
            regM[wSubRowIdx] = As[(4 * BM) + warpRow * WM + 
                wSubRowIdx * WSUBM + threadRowInWarp * TM];
        }

        for (uint wSubColIdx = 0; wSubColIdx < WNITER; ++wSubColIdx) {
            #pragma unroll
            for (uint tn = 0; tn < TN; ++tn) {
                regN[wSubColIdx * TN + tn] = Bs[(4 * BN) + warpCol * WN + 
                    wSubColIdx * WSUBN + threadColInWarp * TN + tn];
            }
        }

        for (uint wSubRowIdx = 0; wSubRowIdx < WMITER; ++wSubRowIdx) {
            for (uint wSubColIdx = 0; wSubColIdx < WNITER; ++wSubColIdx) {
                #pragma unroll
                for (uint tn = 0; tn < TN; ++tn) {
                    const uint idx = (wSubRowIdx * TM) * (WNITER * TN) + 
                        wSubColIdx * TN + tn;
                    threadResults[idx] += regM[wSubRowIdx] * regN[wSubColIdx * TN + tn];
                }
            }
        }
    }

    // Column 5
    {
        for (uint wSubRowIdx = 0; wSubRowIdx < WMITER; ++wSubRowIdx) {
            regM[wSubRowIdx] = As[(5 * BM) + warpRow * WM + 
                wSubRowIdx * WSUBM + threadRowInWarp * TM];
        }

        for (uint wSubColIdx = 0; wSubColIdx < WNITER; ++wSubColIdx) {
            #pragma unroll
            for (uint tn = 0; tn < TN; ++tn) {
                regN[wSubColIdx * TN + tn] = Bs[(5 * BN) + warpCol * WN + 
                    wSubColIdx * WSUBN + threadColInWarp * TN + tn];
            }
        }

        for (uint wSubRowIdx = 0; wSubRowIdx < WMITER; ++wSubRowIdx) {
            for (uint wSubColIdx = 0; wSubColIdx < WNITER; ++wSubColIdx) {
                #pragma unroll
                for (uint tn = 0; tn < TN; ++tn) {
                    const uint idx = (wSubRowIdx * TM) * (WNITER * TN) + 
                        wSubColIdx * TN + tn;
                    threadResults[idx] += regM[wSubRowIdx] * regN[wSubColIdx * TN + tn];
                }
            }
        }
    }

    // Column 6
    {
        for (uint wSubRowIdx = 0; wSubRowIdx < WMITER; ++wSubRowIdx) {
            regM[wSubRowIdx] = As[(6 * BM) + warpRow * WM + 
                wSubRowIdx * WSUBM + threadRowInWarp * TM];
        }

        for (uint wSubColIdx = 0; wSubColIdx < WNITER; ++wSubColIdx) {
            #pragma unroll
            for (uint tn = 0; tn < TN; ++tn) {
                regN[wSubColIdx * TN + tn] = Bs[(6 * BN) + warpCol * WN + 
                    wSubColIdx * WSUBN + threadColInWarp * TN + tn];
            }
        }

        for (uint wSubRowIdx = 0; wSubRowIdx < WMITER; ++wSubRowIdx) {
            for (uint wSubColIdx = 0; wSubColIdx < WNITER; ++wSubColIdx) {
                #pragma unroll
                for (uint tn = 0; tn < TN; ++tn) {
                    const uint idx = (wSubRowIdx * TM) * (WNITER * TN) + 
                        wSubColIdx * TN + tn;
                    threadResults[idx] += regM[wSubRowIdx] * regN[wSubColIdx * TN + tn];
                }
            }
        }
    }

    // Column 7
    {
        for (uint wSubRowIdx = 0; wSubRowIdx < WMITER; ++wSubRowIdx) {
            regM[wSubRowIdx] = As[(7 * BM) + warpRow * WM + 
                wSubRowIdx * WSUBM + threadRowInWarp * TM];
        }

        for (uint wSubColIdx = 0; wSubColIdx < WNITER; ++wSubColIdx) {
            #pragma unroll
            for (uint tn = 0; tn < TN; ++tn) {
                regN[wSubColIdx * TN + tn] = Bs[(7 * BN) + warpCol * WN + 
                    wSubColIdx * WSUBN + threadColInWarp * TN + tn];
            }
        }

        for (uint wSubRowIdx = 0; wSubRowIdx < WMITER; ++wSubRowIdx) {
            for (uint wSubColIdx = 0; wSubColIdx < WNITER; ++wSubColIdx) {
                #pragma unroll
                for (uint tn = 0; tn < TN; ++tn) {
                    const uint idx = (wSubRowIdx * TM) * (WNITER * TN) + 
                        wSubColIdx * TN + tn;
                    threadResults[idx] += regM[wSubRowIdx] * regN[wSubColIdx * TN + tn];
                }
            }
        }
    }

}

// Pattern 0xff (0b11111111) - 8 active columns
__device__ inline void compute_pattern_255(
    const float* __restrict__ As,
    const float* __restrict__ Bs,
    float* __restrict__ threadResults,
    const uint warpRow, const uint warpCol,
    const uint threadRowInWarp, const uint threadColInWarp,
    const uint WM, const uint WN, const uint TM, const uint TN,
    const uint BM, const uint BN, const uint WMITER, const uint WNITER,
    const uint WSUBM, const uint WSUBN
) {
    // Temporary register storage (reused for each column)
    float regM[8];  // Support up to WMITER=8, TM=1
    float regN[32];  // Support up to WNITER=4, TN=8

    // Column 0
    {
        for (uint wSubRowIdx = 0; wSubRowIdx < WMITER; ++wSubRowIdx) {
            regM[wSubRowIdx] = As[(0 * BM) + warpRow * WM + 
                wSubRowIdx * WSUBM + threadRowInWarp * TM];
        }

        for (uint wSubColIdx = 0; wSubColIdx < WNITER; ++wSubColIdx) {
            #pragma unroll
            for (uint tn = 0; tn < TN; ++tn) {
                regN[wSubColIdx * TN + tn] = Bs[(0 * BN) + warpCol * WN + 
                    wSubColIdx * WSUBN + threadColInWarp * TN + tn];
            }
        }

        for (uint wSubRowIdx = 0; wSubRowIdx < WMITER; ++wSubRowIdx) {
            for (uint wSubColIdx = 0; wSubColIdx < WNITER; ++wSubColIdx) {
                #pragma unroll
                for (uint tn = 0; tn < TN; ++tn) {
                    const uint idx = (wSubRowIdx * TM) * (WNITER * TN) + 
                        wSubColIdx * TN + tn;
                    threadResults[idx] += regM[wSubRowIdx] * regN[wSubColIdx * TN + tn];
                }
            }
        }
    }

    // Column 1
    {
        for (uint wSubRowIdx = 0; wSubRowIdx < WMITER; ++wSubRowIdx) {
            regM[wSubRowIdx] = As[(1 * BM) + warpRow * WM + 
                wSubRowIdx * WSUBM + threadRowInWarp * TM];
        }

        for (uint wSubColIdx = 0; wSubColIdx < WNITER; ++wSubColIdx) {
            #pragma unroll
            for (uint tn = 0; tn < TN; ++tn) {
                regN[wSubColIdx * TN + tn] = Bs[(1 * BN) + warpCol * WN + 
                    wSubColIdx * WSUBN + threadColInWarp * TN + tn];
            }
        }

        for (uint wSubRowIdx = 0; wSubRowIdx < WMITER; ++wSubRowIdx) {
            for (uint wSubColIdx = 0; wSubColIdx < WNITER; ++wSubColIdx) {
                #pragma unroll
                for (uint tn = 0; tn < TN; ++tn) {
                    const uint idx = (wSubRowIdx * TM) * (WNITER * TN) + 
                        wSubColIdx * TN + tn;
                    threadResults[idx] += regM[wSubRowIdx] * regN[wSubColIdx * TN + tn];
                }
            }
        }
    }

    // Column 2
    {
        for (uint wSubRowIdx = 0; wSubRowIdx < WMITER; ++wSubRowIdx) {
            regM[wSubRowIdx] = As[(2 * BM) + warpRow * WM + 
                wSubRowIdx * WSUBM + threadRowInWarp * TM];
        }

        for (uint wSubColIdx = 0; wSubColIdx < WNITER; ++wSubColIdx) {
            #pragma unroll
            for (uint tn = 0; tn < TN; ++tn) {
                regN[wSubColIdx * TN + tn] = Bs[(2 * BN) + warpCol * WN + 
                    wSubColIdx * WSUBN + threadColInWarp * TN + tn];
            }
        }

        for (uint wSubRowIdx = 0; wSubRowIdx < WMITER; ++wSubRowIdx) {
            for (uint wSubColIdx = 0; wSubColIdx < WNITER; ++wSubColIdx) {
                #pragma unroll
                for (uint tn = 0; tn < TN; ++tn) {
                    const uint idx = (wSubRowIdx * TM) * (WNITER * TN) + 
                        wSubColIdx * TN + tn;
                    threadResults[idx] += regM[wSubRowIdx] * regN[wSubColIdx * TN + tn];
                }
            }
        }
    }

    // Column 3
    {
        for (uint wSubRowIdx = 0; wSubRowIdx < WMITER; ++wSubRowIdx) {
            regM[wSubRowIdx] = As[(3 * BM) + warpRow * WM + 
                wSubRowIdx * WSUBM + threadRowInWarp * TM];
        }

        for (uint wSubColIdx = 0; wSubColIdx < WNITER; ++wSubColIdx) {
            #pragma unroll
            for (uint tn = 0; tn < TN; ++tn) {
                regN[wSubColIdx * TN + tn] = Bs[(3 * BN) + warpCol * WN + 
                    wSubColIdx * WSUBN + threadColInWarp * TN + tn];
            }
        }

        for (uint wSubRowIdx = 0; wSubRowIdx < WMITER; ++wSubRowIdx) {
            for (uint wSubColIdx = 0; wSubColIdx < WNITER; ++wSubColIdx) {
                #pragma unroll
                for (uint tn = 0; tn < TN; ++tn) {
                    const uint idx = (wSubRowIdx * TM) * (WNITER * TN) + 
                        wSubColIdx * TN + tn;
                    threadResults[idx] += regM[wSubRowIdx] * regN[wSubColIdx * TN + tn];
                }
            }
        }
    }

    // Column 4
    {
        for (uint wSubRowIdx = 0; wSubRowIdx < WMITER; ++wSubRowIdx) {
            regM[wSubRowIdx] = As[(4 * BM) + warpRow * WM + 
                wSubRowIdx * WSUBM + threadRowInWarp * TM];
        }

        for (uint wSubColIdx = 0; wSubColIdx < WNITER; ++wSubColIdx) {
            #pragma unroll
            for (uint tn = 0; tn < TN; ++tn) {
                regN[wSubColIdx * TN + tn] = Bs[(4 * BN) + warpCol * WN + 
                    wSubColIdx * WSUBN + threadColInWarp * TN + tn];
            }
        }

        for (uint wSubRowIdx = 0; wSubRowIdx < WMITER; ++wSubRowIdx) {
            for (uint wSubColIdx = 0; wSubColIdx < WNITER; ++wSubColIdx) {
                #pragma unroll
                for (uint tn = 0; tn < TN; ++tn) {
                    const uint idx = (wSubRowIdx * TM) * (WNITER * TN) + 
                        wSubColIdx * TN + tn;
                    threadResults[idx] += regM[wSubRowIdx] * regN[wSubColIdx * TN + tn];
                }
            }
        }
    }

    // Column 5
    {
        for (uint wSubRowIdx = 0; wSubRowIdx < WMITER; ++wSubRowIdx) {
            regM[wSubRowIdx] = As[(5 * BM) + warpRow * WM + 
                wSubRowIdx * WSUBM + threadRowInWarp * TM];
        }

        for (uint wSubColIdx = 0; wSubColIdx < WNITER; ++wSubColIdx) {
            #pragma unroll
            for (uint tn = 0; tn < TN; ++tn) {
                regN[wSubColIdx * TN + tn] = Bs[(5 * BN) + warpCol * WN + 
                    wSubColIdx * WSUBN + threadColInWarp * TN + tn];
            }
        }

        for (uint wSubRowIdx = 0; wSubRowIdx < WMITER; ++wSubRowIdx) {
            for (uint wSubColIdx = 0; wSubColIdx < WNITER; ++wSubColIdx) {
                #pragma unroll
                for (uint tn = 0; tn < TN; ++tn) {
                    const uint idx = (wSubRowIdx * TM) * (WNITER * TN) + 
                        wSubColIdx * TN + tn;
                    threadResults[idx] += regM[wSubRowIdx] * regN[wSubColIdx * TN + tn];
                }
            }
        }
    }

    // Column 6
    {
        for (uint wSubRowIdx = 0; wSubRowIdx < WMITER; ++wSubRowIdx) {
            regM[wSubRowIdx] = As[(6 * BM) + warpRow * WM + 
                wSubRowIdx * WSUBM + threadRowInWarp * TM];
        }

        for (uint wSubColIdx = 0; wSubColIdx < WNITER; ++wSubColIdx) {
            #pragma unroll
            for (uint tn = 0; tn < TN; ++tn) {
                regN[wSubColIdx * TN + tn] = Bs[(6 * BN) + warpCol * WN + 
                    wSubColIdx * WSUBN + threadColInWarp * TN + tn];
            }
        }

        for (uint wSubRowIdx = 0; wSubRowIdx < WMITER; ++wSubRowIdx) {
            for (uint wSubColIdx = 0; wSubColIdx < WNITER; ++wSubColIdx) {
                #pragma unroll
                for (uint tn = 0; tn < TN; ++tn) {
                    const uint idx = (wSubRowIdx * TM) * (WNITER * TN) + 
                        wSubColIdx * TN + tn;
                    threadResults[idx] += regM[wSubRowIdx] * regN[wSubColIdx * TN + tn];
                }
            }
        }
    }

    // Column 7
    {
        for (uint wSubRowIdx = 0; wSubRowIdx < WMITER; ++wSubRowIdx) {
            regM[wSubRowIdx] = As[(7 * BM) + warpRow * WM + 
                wSubRowIdx * WSUBM + threadRowInWarp * TM];
        }

        for (uint wSubColIdx = 0; wSubColIdx < WNITER; ++wSubColIdx) {
            #pragma unroll
            for (uint tn = 0; tn < TN; ++tn) {
                regN[wSubColIdx * TN + tn] = Bs[(7 * BN) + warpCol * WN + 
                    wSubColIdx * WSUBN + threadColInWarp * TN + tn];
            }
        }

        for (uint wSubRowIdx = 0; wSubRowIdx < WMITER; ++wSubRowIdx) {
            for (uint wSubColIdx = 0; wSubColIdx < WNITER; ++wSubColIdx) {
                #pragma unroll
                for (uint tn = 0; tn < TN; ++tn) {
                    const uint idx = (wSubRowIdx * TM) * (WNITER * TN) + 
                        wSubColIdx * TN + tn;
                    threadResults[idx] += regM[wSubRowIdx] * regN[wSubColIdx * TN + tn];
                }
            }
        }
    }

}

// ============================================================================
// GENERIC FALLBACK FUNCTION
// ============================================================================

// Generic fallback for patterns not explicitly specialized
__device__ inline void compute_pattern_generic(
    const uint8_t pattern,
    const float* __restrict__ As,
    const float* __restrict__ Bs,
    float* __restrict__ threadResults,
    const uint warpRow, const uint warpCol,
    const uint threadRowInWarp, const uint threadColInWarp,
    const uint WM, const uint WN, const uint TM, const uint TN,
    const uint BM, const uint BN, const uint WMITER, const uint WNITER,
    const uint WSUBM, const uint WSUBN
) {
    // Generic implementation with branch to handle any pattern
    float regM[8];  // Support up to WMITER=8, TM=1
    float regN[32];  // Support up to WNITER=4, TN=8

    for (int col = 0; col < 8; ++col) {
        if ((pattern >> col) & 1) {
            // Load from A
            for (uint wSubRowIdx = 0; wSubRowIdx < WMITER; ++wSubRowIdx) {
                regM[wSubRowIdx] = As[(col * BM) + warpRow * WM +
                    wSubRowIdx * WSUBM + threadRowInWarp * TM];
            }

            // Load from B
            for (uint wSubColIdx = 0; wSubColIdx < WNITER; ++wSubColIdx) {
                #pragma unroll
                for (uint tn = 0; tn < TN; ++tn) {
                    regN[wSubColIdx * TN + tn] = Bs[(col * BN) + warpCol * WN +
                        wSubColIdx * WSUBN + threadColInWarp * TN + tn];
                }
            }

            // Multiply-accumulate
            for (uint wSubRowIdx = 0; wSubRowIdx < WMITER; ++wSubRowIdx) {
                for (uint wSubColIdx = 0; wSubColIdx < WNITER; ++wSubColIdx) {
                    #pragma unroll
                    for (uint tn = 0; tn < TN; ++tn) {
                        const uint idx = (wSubRowIdx * TM) * (WNITER * TN) +
                            wSubColIdx * TN + tn;
                        threadResults[idx] += regM[wSubRowIdx] * regN[wSubColIdx * TN + tn];
                    }
                }
            }
        }
    }
}

// ============================================================================
// DISPATCH FUNCTION
// ============================================================================

__device__ inline void dispatch_pattern(
    const uint8_t pattern,
    const float* __restrict__ As,
    const float* __restrict__ Bs,
    float* __restrict__ threadResults,
    const uint warpRow, const uint warpCol,
    const uint threadRowInWarp, const uint threadColInWarp,
    const uint WM, const uint WN, const uint TM, const uint TN,
    const uint BM, const uint BN, const uint WMITER, const uint WNITER,
    const uint WSUBM, const uint WSUBN
) {
    switch(pattern) {
        case 15: compute_pattern_15(As, Bs, threadResults, warpRow, warpCol, threadRowInWarp, threadColInWarp, WM, WN, TM, TN, BM, BN, WMITER, WNITER, WSUBM, WSUBN); break;
        case 128: compute_pattern_128(As, Bs, threadResults, warpRow, warpCol, threadRowInWarp, threadColInWarp, WM, WN, TM, TN, BM, BN, WMITER, WNITER, WSUBM, WSUBN); break;
        case 192: compute_pattern_192(As, Bs, threadResults, warpRow, warpCol, threadRowInWarp, threadColInWarp, WM, WN, TM, TN, BM, BN, WMITER, WNITER, WSUBM, WSUBN); break;
        case 240: compute_pattern_240(As, Bs, threadResults, warpRow, warpCol, threadRowInWarp, threadColInWarp, WM, WN, TM, TN, BM, BN, WMITER, WNITER, WSUBM, WSUBN); break;
        case 252: compute_pattern_252(As, Bs, threadResults, warpRow, warpCol, threadRowInWarp, threadColInWarp, WM, WN, TM, TN, BM, BN, WMITER, WNITER, WSUBM, WSUBN); break;
        case 255: compute_pattern_255(As, Bs, threadResults, warpRow, warpCol, threadRowInWarp, threadColInWarp, WM, WN, TM, TN, BM, BN, WMITER, WNITER, WSUBM, WSUBN); break;
        default:
            // Fallback to generic computation for unhandled patterns
            compute_pattern_generic(pattern, As, Bs, threadResults,
                warpRow, warpCol, threadRowInWarp, threadColInWarp,
                WM, WN, TM, TN, BM, BN, WMITER, WNITER, WSUBM, WSUBN);
            break;
    }
}
